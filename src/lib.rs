//! # TRIAD
//! 
//! Квантово-вдохновленная распределенная сеть следующего поколения.
//! 
//! TRIAD — это система, реализующая виртуальное квантовое поле для распределенного 
//! хранения и обработки информации, которая использует принципы квантовой механики, 
//! такие как суперпозиция, запутанность и интерференция, для достижения:
//! 
//! - Мгновенной синхронизации через симуляцию квантовой запутанности
//! - Принятия решений через квантовую интерференцию волновых функций
//! - Высокой энергоэффективности
//! - Квантового сжатия данных
//! - Оптимизации через квантовый отжиг
//! 
//! ## Использование
//! 
//! ```rust
//! use triad::api::QuantumEngine;
//! 
//! // Создаем квантовый движок с 2 кубитами
//! let mut engine = QuantumEngine::new(2);
//! 
//! // Применяем гейт Адамара к кубиту 0
//! engine.hadamard(0);
//! 
//! // Применяем CNOT между кубитами 0 и 1 (запутывание)
//! engine.cnot(0, 1);
//! 
//! // Измеряем кубит 0
//! let result = engine.measure(0);
//! println!("Результат измерения: {}", result);
//! ```
//! 
//! ## Текущий статус
//! 
//! Проект находится на ранней стадии разработки. Текущая реализация фокусируется
//! на создании ядра квантовой симуляции и виртуального квантового поля.

/// Ядро системы: базовые структуры для квантовой симуляции
pub mod core;

/// Интеграция с QuEST (Quantum Exact Simulation Toolkit)
pub mod quest;

/// Примеры использования квантовых симуляторов и алгоритмов
pub mod examples;

/// Публичный API библиотеки
pub mod api;

// Реэкспортируем основные компоненты для удобства
pub use api::{QuantumEngine, QuantumSimulator, QuantumState};

/// Версия библиотеки
pub const VERSION: &str = env!("CARGO_PKG_VERSION");

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn quantum_engine_works() {
        let mut engine = api::QuantumEngine::new(1);
        
        // По умолчанию кубит в состоянии |0⟩
        let state = engine.simulator().get_state();
        assert!((state.probability(0) - 1.0).abs() < 1e-10);
        
        // После применения X-гейта, кубит должен быть в состоянии |1⟩
        engine.x(0);
        let state = engine.simulator().get_state();
        assert!((state.probability(1) - 1.0).abs() < 1e-10);
    }
} 